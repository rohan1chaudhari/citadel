#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { spawn } from 'node:child_process';

const ROOT = path.resolve(path.dirname(new URL(import.meta.url).pathname), '..');

function log(...a) { console.log('[citadel-app]', ...a); }
function fail(msg) { console.error('[citadel-app] ERROR:', msg); process.exit(1); }

function slugify(input) {
  return input.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
}

async function exists(p) {
  try { await fs.access(p); return true; } catch { return false; }
}

async function mkdirp(p) { await fs.mkdir(p, { recursive: true }); }

function parseFlags(argv) {
  const flags = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (!a.startsWith('--')) continue;
    const k = a.slice(2);
    const v = argv[i + 1] && !argv[i + 1].startsWith('--') ? argv[++i] : 'true';
    flags[k] = v;
  }
  return flags;
}

function isTrue(v) {
  return ['1', 'true', 'yes', 'on'].includes(String(v ?? '').toLowerCase());
}

async function writeTemplate(appDir, { appId, appName, port }) {
  const pkg = {
    name: `citadel-external-${appId}`,
    version: '0.1.0',
    private: true,
    type: 'module',
    scripts: { start: 'node server.mjs', dev: 'node server.mjs', build: 'echo "No build step"' },
    dependencies: { express: '^4.19.2' }
  };

  const manifest = {
    id: appId,
    name: appName,
    version: '0.1.0',
    entry: '/',
    health: '/healthz',
    permissions: [],
    runtime: {
      cwd: appDir,
      build: 'npm run build',
      start: 'npm start',
      port: port
    }
  };

  const server = `import express from 'express';\n\nconst app = express();\nconst port = Number(process.env.PORT || ${port});\napp.use(express.json({ limit: '1mb' }));\n\napp.get('/healthz', (_req, res) => {\n  res.json({ ok: true, app: '${appId}', ts: new Date().toISOString() });\n});\n\napp.get('/', (_req, res) => {\n  res.type('html').send(\`<!doctype html><html><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>${appName}</title><style>body{font-family:system-ui;margin:0;background:#fafafa}.wrap{max-width:760px;margin:40px auto;padding:20px}.card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px}</style></head><body><div class=\"wrap\"><div class=\"card\"><h1>${appName}</h1><p>Standalone Citadel app starter.</p><p>Try health: <code>/healthz</code></p></div></div></body></html>\`);\n});\n\napp.listen(port, () => console.log('${appId} listening on :' + port));\n`;

  const readme = `# ${appName}\n\nGenerated by \`scripts/citadel-app.mjs\`.\n\n## Run\n\n\`\`\`bash\nnpm install\nnpm start\n\`\`\`\n\n## Register with Citadel\n\n\`\`\`bash\nnode ${path.relative(appDir, path.join(ROOT, 'scripts', 'citadel-app.mjs'))} install ${appDir} --url http://localhost:${port}\n\`\`\`\n`;

  const dockerfile = `FROM node:22-alpine\nWORKDIR /app\nCOPY package.json package-lock.json* ./\nRUN npm install --omit=dev\nCOPY . .\nENV PORT=${port}\nEXPOSE ${port}\nCMD [\"npm\", \"start\"]\n`;
  const dockerignore = `node_modules\n.git\n.gitignore\n*.log\n`;

  await fs.writeFile(path.join(appDir, 'package.json'), JSON.stringify(pkg, null, 2) + '\n');
  await fs.writeFile(path.join(appDir, 'citadel.app.json'), JSON.stringify(manifest, null, 2) + '\n');
  await fs.writeFile(path.join(appDir, 'server.mjs'), server);
  await fs.writeFile(path.join(appDir, 'README.md'), readme);
  await fs.writeFile(path.join(appDir, 'Dockerfile'), dockerfile);
  await fs.writeFile(path.join(appDir, '.dockerignore'), dockerignore);
}

async function cmdCreate(argv) {
  const name = argv[0];
  if (!name) fail('Usage: create <name> [--out <dir>] [--port <n>]');
  const flags = parseFlags(argv.slice(1));
  const appId = slugify(name);
  const outRoot = flags.out ? path.resolve(flags.out) : path.join(ROOT, 'external-apps');
  const appDir = path.join(outRoot, appId);
  const port = Number(flags.port || 4020);
  if (await exists(appDir)) fail(`target already exists: ${appDir}`);
  await mkdirp(appDir);
  await writeTemplate(appDir, { appId, appName: name, port });
  log('Created app at', appDir);
  log('Next: npm install && npm start');
}

function run(command, args, cwd) {
  return new Promise((resolve, reject) => {
    const p = spawn(command, args, { cwd, stdio: 'inherit' });
    p.on('close', (code) => (code === 0 ? resolve() : reject(new Error(`${command} exited ${code}`))));
  });
}

async function cmdDev(argv) {
  const target = argv[0];
  if (!target) fail('Usage: dev <app-dir>');
  const appDir = path.resolve(target);
  if (!(await exists(path.join(appDir, 'package.json')))) fail('package.json not found in app dir');
  if (!(await exists(path.join(appDir, 'node_modules')))) await run('npm', ['install'], appDir);
  await run('npm', ['run', 'dev'], appDir);
}

async function cmdInstall(argv) {
  const target = argv[0];
  if (!target) fail('Usage: install <app-dir> [--url <http://localhost:PORT>] [--host http://localhost:3000] [--icon <path>] [--docker-build] [--docker-image <name>]');
  const flags = parseFlags(argv.slice(1));
  const appDir = path.resolve(target);
  const host = String(flags.host || 'http://localhost:3000').trim().replace(/\/$/, '');

  const manifestPath = path.join(appDir, 'citadel.app.json');
  if (!(await exists(manifestPath))) fail(`manifest not found: ${manifestPath}`);
  const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));

  let url = String(flags.url || '').trim();
  if (!url && manifest?.runtime?.port) {
    url = `http://localhost:${manifest.runtime.port}`;
    log('No --url passed; inferred upstream from runtime.port ->', url);
  }
  if (!url) fail('--url is required (or set runtime.port in manifest)');

  if (isTrue(flags['docker-build'])) {
    const image = String(flags['docker-image'] || `citadel/${manifest.id}:latest`);
    if (!(await exists(path.join(appDir, 'Dockerfile')))) {
      fail('Dockerfile not found. Create one or skip --docker-build.');
    }
    log('Building Docker image:', image);
    await run('docker', ['build', '-t', image, '.'], appDir);
    log('Docker image built:', image);
  }

  const res = await fetch(`${host}/api/apps`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ manifest, upstreamBaseUrl: url, enabled: true })
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok) fail(`install failed (${res.status}): ${JSON.stringify(data)}`);
  log('Installed:', manifest.id, '->', url);

  if (flags.icon) {
    const iconSrc = path.resolve(String(flags.icon));
    if (!(await exists(iconSrc))) fail(`icon file not found: ${iconSrc}`);
    const logosDir = path.join(ROOT, 'host', 'public', 'app-logos');
    await mkdirp(logosDir);
    const iconDest = path.join(logosDir, `${manifest.id}-logo.png`);
    await fs.copyFile(iconSrc, iconDest);
    log('Icon installed:', iconDest);
  }

  // Auto-apply runtime if present in manifest
  if (manifest.runtime) {
    log('Runtime config detected, applying...');
    const runtimeRes = await fetch(`${host}/api/apps/${manifest.id}/runtime`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ action: 'apply' })
    });
    const runtimeData = await runtimeRes.json().catch(() => ({}));
    if (runtimeRes.ok) {
      log('Runtime applied:', runtimeData.message);
    } else {
      log('Runtime apply warning:', runtimeData.error || 'Unknown error');
    }
  }
}

async function cmdRuntime(argv) {
  const subcmd = argv[0];
  const appId = argv[1];
  const host = 'http://localhost:3000';

  if (!subcmd || !appId || ['-h', '--help', 'help'].includes(subcmd)) {
    console.log(`Usage: citadel-app runtime <action> <app-id>

Actions:
  status    - Show runtime status for app
  apply     - Generate systemd unit and apply runtime config
  start     - Start the app service
  stop      - Stop the app service
  restart   - Restart the app service
  enable    - Enable app to start on boot
  disable   - Disable app from starting on boot`);
    return;
  }

  const validActions = ['status', 'apply', 'start', 'stop', 'restart', 'enable', 'disable'];
  if (!validActions.includes(subcmd)) {
    fail(`Invalid action: ${subcmd}. Use: ${validActions.join(', ')}`);
  }

  if (subcmd === 'status') {
    const res = await fetch(`${host}/api/apps/${appId}/runtime`);
    const data = await res.json().catch(() => ({}));
    if (!res.ok) fail(data.error || `Failed to get status for ${appId}`);
    console.log(`App: ${data.appId}`);
    console.log(`Runtime: ${data.runtime ? JSON.stringify(data.runtime, null, 2) : 'Not configured'}`);
    console.log(`Unit generated: ${data.unitGenerated}`);
    console.log(`Status: ${JSON.stringify(data.status, null, 2)}`);
    if (data.unitContent) {
      console.log(`\nSystemd unit:\n${data.unitContent}`);
    }
    return;
  }

  const res = await fetch(`${host}/api/apps/${appId}/runtime`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ action: subcmd })
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok) fail(data.error || `Failed to ${subcmd} ${appId}`);
  log(data.message || `${subcmd} completed`);
  if (data.status) {
    log('Current status:', JSON.stringify(data.status));
  }
}

async function main() {
  const [, , cmd, ...rest] = process.argv;
  if (!cmd || ['-h', '--help', 'help'].includes(cmd)) {
    console.log('Usage:\n  citadel-app create <name> [--out <dir>] [--port <n>]\n  citadel-app dev <app-dir>\n  citadel-app install <app-dir> [--url <http://localhost:PORT>] [--host <http://localhost:3000>] [--icon <path>] [--docker-build] [--docker-image <name>]\n  citadel-app runtime <status|apply|start|stop|restart|enable|disable> <app-id>');
    return;
  }

  if (cmd === 'create') return cmdCreate(rest);
  if (cmd === 'dev') return cmdDev(rest);
  if (cmd === 'install') return cmdInstall(rest);
  if (cmd === 'runtime') return cmdRuntime(rest);
  fail(`unknown command: ${cmd}`);
}

main().catch((e) => fail(String(e?.message || e)));
